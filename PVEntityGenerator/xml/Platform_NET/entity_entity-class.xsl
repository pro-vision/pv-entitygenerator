<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0"
>

<xsl:import href="platform_defaults.xsl"/>

<xsl:output method="text" encoding="ISO-8859-1"/>


<xsl:template match="/">
  <xsl:apply-templates select="$db-definition/entities/entity[@name=$entity]"/>
</xsl:template>



<!-- ***** Class File generieren ***** -->
<xsl:template match="entity">
<xsl:if test="$generate-entity/parameters/parameter[@name='generate-entity']='true'
    or $generate-entity/parameters/parameter[@name='generate-enumeration']='true'">

  <!-- File Header, package, import statements -->
  <xsl:if test="$platform/parameters/parameter[@name='file-header']!=''">
    <xsl:value-of select="$platform/parameters/parameter[@name='file-header']"/>
    <xsl:text><![CDATA[
]]></xsl:text>
  </xsl:if>
  <xsl:text>using System;
using System.Data.SqlTypes;
</xsl:text>
  <xsl:if test="$generate-entity/parameters/parameter[@name='generate-entity']='true' and $generate-entity-platform/parameters/parameter[@name='generate-serializable']='true'">
    <xsl:text>using System.Runtime.Serialization;
</xsl:text>
  </xsl:if>
  <xsl:text>using PVFramework;

namespace </xsl:text><xsl:value-of select="$platform/parameters/parameter[@name='entity-namespace']"/><xsl:text> {

</xsl:text>

  <xsl:if test="$generate-entity/parameters/parameter[@name='generate-enumeration']='true'">

    <!-- Enumeration -->
    <xsl:apply-templates select="." mode="enumeration"/>

  </xsl:if>


  <!-- Class-Kommentar -->
  <xsl:if test="$generate-comments">
    <xsl:text>  /// &lt;summary&gt;
</xsl:text>
    <xsl:if test="@description">
      <xsl:text>  /// </xsl:text><xsl:value-of select="@description"/><xsl:text>&lt;br/&gt;
</xsl:text>
    </xsl:if>
    <xsl:text>  /// The class &lt;c&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>&lt;/c&gt; is an object wrapper for the table &lt;i&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>&lt;/i&gt;.
  /// It extends the &lt;c&gt;PVDbObject&lt;/c&gt; class and supports methods for storing or deleting an entity in the database.
</xsl:text>
    <xsl:if test="$generate-entity/parameters/parameter[@name='generate-home']='true'">
      <xsl:text>  /// The &lt;c&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>Home&lt;/c&gt; class provides methods for creating and fetching entities.
  /// &lt;see cref="</xsl:text><xsl:value-of select="$platform/parameters/parameter[@name='entity-namespace']"/><xsl:text>.</xsl:text><xsl:value-of select="$entity"/><xsl:text>Home"/&gt;
</xsl:text>
    </xsl:if>
    <xsl:text>  /// &lt;see cref="PVFramework.PVDbObject"/&gt;
  /// Generated by PVEntityGenerator
  /// &lt;/summary&gt;
</xsl:text>
  </xsl:if>

  <!-- Class Beginn -->
  <xsl:if test="$generate-entity/parameters/parameter[@name='generate-entity']='true' and $generate-entity-platform/parameters/parameter[@name='generate-serializable']='true'">
    <xsl:text>  [Serializable]
</xsl:text>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="$generate-entity/parameters/parameter[@name='generate-entity']='true'">
      <xsl:text>  public class </xsl:text><xsl:value-of select="$entity"/><xsl:text> : PVDbObject {

</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>  public abstract class </xsl:text><xsl:value-of select="$entity"/><xsl:text> {

</xsl:text>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:if test="$generate-entity/parameters/parameter[@name='generate-entity']='true'">

    <!-- Constructor -->
    <xsl:apply-templates select="." mode="constructor"/>

    <!-- Attributes -->
    <xsl:apply-templates select="." mode="attributes"/>

    <!-- Get/Set-Methods -->
    <xsl:if test="$platform/parameters/parameter[@name='getsetmethods']='true'">
      <xsl:apply-templates select="." mode="get-set"/>
    </xsl:if>

    <!-- Constraint-Checks -->
    <xsl:apply-templates select="." mode="constraint-checks"/>

  </xsl:if>

  <xsl:if test="$generate-entity/parameters/parameter[@name='generate-enumeration']='true'">

    <!-- Zusatzmethoden für Enumeration -->
    <xsl:apply-templates select="." mode="enumeration-methods"/>

  </xsl:if>

  <!-- Placeholder for manual class extensions -->
  <xsl:text>//+++ Custom class extensions START +++
// To prevent deleting your changes from PVEntityGenerator put your manual class extensions only here

//+++ Custom class extensions END +++
</xsl:text>

  <!-- Class End -->
  <xsl:text>
  }

}
</xsl:text>

</xsl:if>
</xsl:template>



<!-- ***** Constructor ***** -->
<xsl:template match="entity" mode="constructor">
  <xsl:if test="$generate-comments">
    <xsl:text>    /// &lt;summary&gt;
    /// Initializes a newly created &lt;c&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>&lt;/c&gt; object.
    /// Normally a Database wrapper object is not instanciated directly, but is returned by a create or find method from the &lt;c&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>Home&lt;/c&gt; class.
    /// &lt;/summary&gt;
</xsl:text>
  </xsl:if>
    <xsl:text>    public </xsl:text><xsl:value-of select="$entity"/><xsl:text>() {
</xsl:text>

    <!-- PVDbAttribute-Definitionen -->
    <xsl:text>      PVDbAttribute[] attr = {
</xsl:text>
    <xsl:for-each select="attributes/attribute">
      <xsl:variable name="type">
        <xsl:choose>
          <xsl:when test="@type='DECIMAL'">FLOAT</xsl:when>
          <xsl:otherwise><xsl:value-of select="@type"/></xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
    
      <xsl:text>        new PVDbAttribute("</xsl:text><xsl:value-of select="@name"/><xsl:text>", </xsl:text>
      <xsl:text>PVDbSQLType.</xsl:text><xsl:value-of select="$type"/><xsl:text>, </xsl:text>
      <xsl:choose>
        <xsl:when test="@required='true'"><xsl:text>true</xsl:text></xsl:when>
        <xsl:otherwise><xsl:text>false</xsl:text></xsl:otherwise>
      </xsl:choose>
      <xsl:if test="@type='VARCHAR'">
        <xsl:text>, </xsl:text><xsl:value-of select="@size"/>
      </xsl:if>
      <xsl:text>)</xsl:text>
      <xsl:if test="position() &lt; last()">
        <xsl:text>,
</xsl:text>
      </xsl:if>
    </xsl:for-each>
    <xsl:text>
      };
      mattr = attr;
</xsl:text>

    <!-- Default values -->
    <xsl:for-each select="attributes/attribute[@default-value!='']">
      <xsl:variable name="enum-type">
        <xsl:call-template name="variable-enum-type">
          <xsl:with-param name="attribute" select="."/>
          <xsl:with-param name="entity" select="../.."/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="value">
        <xsl:call-template name="format-type-value">
          <xsl:with-param name="type" select="@type"/>
          <xsl:with-param name="value" select="@default-value"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:text>      this.</xsl:text>
      <xsl:choose>
        <xsl:when test="@name='vstamp'">VStamp</xsl:when>
        <xsl:otherwise><xsl:value-of select="@name"/></xsl:otherwise>
      </xsl:choose>
      <xsl:text> = </xsl:text>

      <xsl:choose>
        <xsl:when test="$enum-type!=''">
          <xsl:variable name="generate-foreign-entity" select="key('generate-entity', substring-before($enum-type, 'Enum'))"/>
          <xsl:value-of select="$enum-type"/>
          <xsl:text>.</xsl:text>
          <xsl:value-of select="$generate-foreign-entity/enumeration-entries/enumeration-entry[@id=$value]/@identifier"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$value"/>
        </xsl:otherwise>
      </xsl:choose>

      <xsl:text>;
</xsl:text>
    </xsl:for-each>

    <xsl:text>      InitializeAttributeValueChangedHandler();
    }

</xsl:text>

  <xsl:if test="$generate-entity-platform/parameters/parameter[@name='generate-serializable']='true'">
    <xsl:if test="$generate-comments">
      <xsl:text>    /// &lt;summary&gt;
    /// Constructor for de-serializing objects.
    /// &lt;/summary&gt;
    /// &lt;param name="info"&gt;Serialization container.&lt;/param&gt;
    /// &lt;param name="context"&gt;Serialization context.&lt;/param&gt;
</xsl:text>
    </xsl:if>
    <xsl:text>    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public </xsl:text><xsl:value-of select="$entity"/>
    <xsl:text>(SerializationInfo info, StreamingContext context) : base(info, context) {}

</xsl:text>
  </xsl:if>

</xsl:template>



<!-- ***** Attribute definitions ***** -->
<xsl:template match="entity" mode="attributes">

  <xsl:for-each select="attributes/attribute">

    <xsl:variable name="attribute-name">
      <xsl:choose>
        <xsl:when test="@type='VSTAMP'">VStamp</xsl:when>
        <xsl:otherwise><xsl:value-of select="@name"/></xsl:otherwise>
      </xsl:choose>
    </xsl:variable>


    <xsl:variable name="comment">
      <xsl:if test="$generate-comments">
        <xsl:text>    /// &lt;summary&gt;
    /// </xsl:text>
        <xsl:choose>
          <xsl:when test="@description!=''"><xsl:value-of select="@description"/></xsl:when>
          <xsl:otherwise><xsl:text>Attribute '</xsl:text><xsl:value-of select="@name"/><xsl:text>'.</xsl:text></xsl:otherwise>
        </xsl:choose>
        <xsl:if test="@required='true'">
          <xsl:text> Required.</xsl:text>
        </xsl:if>
        <xsl:if test="@default-value!=''">
          <xsl:text>&lt;br/&gt;
    /// Default value for new objects: &lt;b&gt;</xsl:text><xsl:value-of select="@default-value"/><xsl:text>&lt;/b&gt;</xsl:text>
        </xsl:if>
        <xsl:text>
    /// &lt;/summary&gt;
</xsl:text>
    </xsl:if>
    </xsl:variable>

    <!-- Attribute definition -->
    <xsl:if test="$generate-entity/parameters/parameter[@name='generate-getter']='true' or $generate-entity/parameters/parameter[@name='generate-setter']='true'">

    <xsl:variable name="enum-type">
      <xsl:call-template name="variable-enum-type">
        <xsl:with-param name="attribute" select="."/>
        <xsl:with-param name="entity" select="../.."/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$comment"/>
    <xsl:if test="@deprecated='true'">
      <xsl:text>    [Obsolete]
</xsl:text>
    </xsl:if>
    <xsl:text>    public </xsl:text>
    <xsl:choose>
      <xsl:when test="$enum-type!=''">
        <xsl:value-of select="$enum-type"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="variable-type">
          <xsl:with-param name="type" select="@type"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text> </xsl:text><xsl:value-of select="$attribute-name"/><xsl:text> {
</xsl:text>

    <xsl:if test="$generate-entity/parameters/parameter[@name='generate-getter']='true'">

    <xsl:text>      get {
        return </xsl:text>
    <xsl:if test="$enum-type!=''">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="$enum-type"/>
      <xsl:text>)</xsl:text>
    </xsl:if>
    <xsl:text>mattr[</xsl:text><xsl:value-of select="position()-1"/><xsl:text>].Get</xsl:text>
    <xsl:call-template name="method-type">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>();
      }
</xsl:text>

    </xsl:if>

    <xsl:if test="$generate-entity/parameters/parameter[@name='generate-setter']='true'">

    <xsl:text>      set {
        mattr[</xsl:text><xsl:value-of select="position()-1"/><xsl:text>].Set</xsl:text>
    <xsl:call-template name="method-type">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>(</xsl:text>
    <xsl:if test="$enum-type!=''">
      <xsl:text>(int)</xsl:text>
    </xsl:if>
    <xsl:text>value);
      }
</xsl:text>

    </xsl:if>

<xsl:text>    }

</xsl:text>

    </xsl:if>

  </xsl:for-each>

</xsl:template>



<!-- ***** Get/Set-Methods (for backward compatibility) ***** -->
<xsl:template match="entity" mode="get-set">

  <xsl:for-each select="attributes/attribute">

    <xsl:variable name="attribute-name">
      <xsl:choose>
        <xsl:when test="@type='VSTAMP'">VStamp</xsl:when>
        <xsl:otherwise><xsl:value-of select="@name"/></xsl:otherwise>
      </xsl:choose>
    </xsl:variable>


    <xsl:variable name="comment">
      <xsl:if test="$generate-comments">
        <xsl:text>    /// &lt;summary&gt;
    /// </xsl:text>
        <xsl:if test="@required='true'">
          <xsl:text>Required. </xsl:text>
        </xsl:if>
        <xsl:choose>
          <xsl:when test="@description!=''"><xsl:value-of select="@description"/></xsl:when>
          <xsl:otherwise><xsl:text>Attribute '</xsl:text><xsl:value-of select="@name"/><xsl:text>'.</xsl:text></xsl:otherwise>
        </xsl:choose>
        <xsl:if test="@default-value!=''">
          <xsl:text>&lt;br/&gt;
    /// Default value for new objects: &lt;b&gt;</xsl:text><xsl:value-of select="@default-value"/><xsl:text>&lt;/b&gt;</xsl:text>
        </xsl:if>
        <xsl:text>
    /// &lt;/summary&gt;
</xsl:text>
    </xsl:if>
    </xsl:variable>

    <xsl:if test="$generate-entity/parameters/parameter[@name='generate-getter']='true'">

    <!-- Get Method -->
    <xsl:variable name="enum-type">
      <xsl:call-template name="variable-enum-type">
        <xsl:with-param name="attribute" select="."/>
        <xsl:with-param name="entity" select="../.."/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$comment"/>
    <xsl:text>    public </xsl:text>
    <xsl:choose>
      <xsl:when test="$enum-type!=''">
        <xsl:value-of select="$enum-type"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="variable-type">
          <xsl:with-param name="type" select="@type"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text> Get</xsl:text><xsl:value-of select="$attribute-name"/><xsl:text>() {
      return </xsl:text>
    <xsl:if test="$enum-type!=''">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="$enum-type"/>
      <xsl:text>)</xsl:text>
    </xsl:if>
    <xsl:text>mattr[</xsl:text><xsl:value-of select="position()-1"/><xsl:text>].Get</xsl:text>
    <xsl:call-template name="method-type">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>();
    }

</xsl:text>

    </xsl:if>

    <xsl:if test="$generate-entity/parameters/parameter[@name='generate-setter']">

    <!-- Set Method -->
    <xsl:variable name="enum-type">
      <xsl:call-template name="variable-enum-type">
        <xsl:with-param name="attribute" select="."/>
        <xsl:with-param name="entity" select="../.."/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$comment"/>
    <xsl:text>    public void Set</xsl:text><xsl:value-of select="$attribute-name"/><xsl:text>(</xsl:text>
    <xsl:choose>
      <xsl:when test="$enum-type!=''">
        <xsl:value-of select="$enum-type"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="variable-type">
          <xsl:with-param name="type" select="@type"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text> p</xsl:text>
    <xsl:call-template name="type-prefix">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>Value) {
      mattr[</xsl:text><xsl:value-of select="position()-1"/><xsl:text>].Set</xsl:text>
    <xsl:call-template name="method-type">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>(</xsl:text>
    <xsl:if test="$enum-type!=''">
      <xsl:text>(int)</xsl:text>
    </xsl:if>
    <xsl:text>p</xsl:text>
    <xsl:call-template name="type-prefix">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>Value);
    }

</xsl:text>

    </xsl:if>

  </xsl:for-each>

</xsl:template>



<!-- ***** Constraing-Checks ***** -->
<xsl:template match="entity" mode="constraint-checks">

  <xsl:variable name="foreign-key-check" select="key('foreign-key-check', $entity)"/>
  <xsl:variable name="foreign-key-cascading-delete" select="key('foreign-key-cascading-delete', $entity)"/>

  <!-- Constraint Checks -->
  <xsl:if test="$foreign-key-check and $generate-entity/parameters/parameter[@name='generate-removecheck']='true'">
    <xsl:if test="$generate-comments">
      <xsl:text>    /// &lt;summary&gt;
    /// Checks for existing records in Table</xsl:text>
      <xsl:if test="count($foreign-key-check) &gt; 1"><xsl:text>s</xsl:text></xsl:if><xsl:text> </xsl:text>
      <xsl:for-each select="$foreign-key-check">
        <xsl:text>&lt;i&gt;</xsl:text>
        <xsl:value-of select="../../@name"/>
        <xsl:text>&lt;/i&gt;</xsl:text>
        <xsl:choose>
          <xsl:when test="position() &lt; last()-1"><xsl:text>, </xsl:text></xsl:when>
          <xsl:when test="position() = last()-1"><xsl:text> and </xsl:text></xsl:when>
        </xsl:choose>
      </xsl:for-each>
      <xsl:text>.
    /// In this case, the entity cannot be removed.
    /// &lt;/summary&gt;
</xsl:text>
    </xsl:if>

    <xsl:text>    public override void CheckRemoveConstraints(PVDbConnection pcon) {
      base.CheckRemoveConstraints(pcon);

      PVQueryBuilder qb;
      PVDbPreparedStatement stmt;
      int intObjCount;

</xsl:text>
    <xsl:for-each select="$foreign-key-check">
      <xsl:variable name="foreign-entity" select="../../@name"/>

      <xsl:text>      // Check Table </xsl:text><xsl:value-of select="$foreign-entity"/><xsl:text>.
      qb = new PVQueryBuilder("COUNT(*)", "</xsl:text><xsl:value-of select="$foreign-entity"/><xsl:text>", "</xsl:text>
      <xsl:value-of select="attribute-ref/@attribute"/><xsl:text>=?");
      stmt = pcon.PrepareStatement(qb.GetSQL());
      stmt.SetInt(1, this.</xsl:text><xsl:value-of select="attribute-ref/@foreign-attribute"/><xsl:text>);
      intObjCount = stmt.ExecuteScalarInt();
      stmt.Close();
      if (intObjCount!=0) {
        throw new PVExceptionRemoveConstraint("</xsl:text>
      <xsl:call-template name="replace-string">
        <xsl:with-param name="text" select="$generate-entity/remove-constraint-messages/remove-constraint-message[@foreign-entity=$foreign-entity]"/>
        <xsl:with-param name="replace">&quot;</xsl:with-param>
        <xsl:with-param name="with">\&quot;</xsl:with-param>
      </xsl:call-template>
      <xsl:text>");
      }

</xsl:text>

    </xsl:for-each>
    <xsl:text>    }

</xsl:text>

  </xsl:if>

  <!-- Cascading Deletes -->
  <xsl:if test="$foreign-key-cascading-delete">
    <xsl:if test="$generate-comments">
     <xsl:text>    /// &lt;summary&gt;
    /// Automatically removes dependent objects in Table</xsl:text>
      <xsl:if test="count($foreign-key-cascading-delete) &gt; 1"><xsl:text>s</xsl:text></xsl:if><xsl:text> </xsl:text>
      <xsl:for-each select="$foreign-key-cascading-delete">
        <xsl:text>&lt;i&gt;</xsl:text>
        <xsl:value-of select="../../@name"/>
        <xsl:text>&lt;/i&gt;</xsl:text>
        <xsl:choose>
          <xsl:when test="position() &lt; last()-1"><xsl:text>, </xsl:text></xsl:when>
          <xsl:when test="position() = last()-1"><xsl:text> and </xsl:text></xsl:when>
        </xsl:choose>
      </xsl:for-each>
      <xsl:text>.
    /// &lt;/summary&gt;
</xsl:text>
    </xsl:if>

    <xsl:text>    protected override void RemoveDependentObjects(PVDbConnection pcon) {

</xsl:text>
    <xsl:for-each select="$foreign-key-cascading-delete">
      <xsl:text>      // Remove from table </xsl:text><xsl:value-of select="../../@name"/><xsl:text>
      </xsl:text><xsl:value-of select="../../@name"/><xsl:text>[] a</xsl:text>
      <xsl:value-of select="../../@name"/><xsl:value-of select="position()"/><xsl:text> = </xsl:text>
      <xsl:value-of select="../../@name"/><xsl:text>Home.FindBy</xsl:text>
      <xsl:choose>
        <xsl:when test="substring(attribute-ref/@attribute,string-length(attribute-ref/@attribute)-1)='ID'"><xsl:value-of select="substring(attribute-ref/@attribute, 1, string-length(attribute-ref/@attribute)-2)"/></xsl:when>
        <xsl:otherwise><xsl:value-of select="attribute-ref/@attribute"/></xsl:otherwise>
      </xsl:choose>
      <xsl:text>(this.</xsl:text><xsl:value-of select="attribute-ref/@foreign-attribute"/><xsl:text>, pcon);
      for (int intIndex=0; intIndex&lt;a</xsl:text><xsl:value-of select="../../@name"/><xsl:value-of select="position()"/><xsl:text>.Length; intIndex++) {
        a</xsl:text><xsl:value-of select="../../@name"/><xsl:value-of select="position()"/><xsl:text>[intIndex].Remove(pcon);
      }

</xsl:text>
    </xsl:for-each>
    <xsl:text>    }

</xsl:text>
  </xsl:if>

</xsl:template>



<!-- ***** Enumeration generieren ***** -->
<xsl:template match="entity" mode="enumeration">

  <!-- Class-Kommentar -->
  <xsl:if test="$generate-comments">
    <xsl:text>  /// &lt;summary&gt;
  /// Enumeration &lt;c&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>&lt;/c&gt;.&lt;br/&gt;
  /// Generated by PVEntityGenerator
  /// &lt;/summary&gt;
</xsl:text>
  </xsl:if>

  <!-- Class Beginn -->
  <xsl:text>  public enum </xsl:text><xsl:value-of select="$entity"/><xsl:text>Enum {

</xsl:text>

  <xsl:for-each select="$generate-entity/enumeration-entries/enumeration-entry[@generate='true']">
    <xsl:sort select="@identifier"/>
    <xsl:if test="$generate-comments and @description!=''">
      <xsl:text>    /// &lt;summary&gt;
    /// </xsl:text><xsl:value-of select="@description"/><xsl:text>
    /// &lt;/summary&gt;
</xsl:text>
    </xsl:if>
    <xsl:text><![CDATA[    ]]></xsl:text><xsl:value-of select="@identifier"/>
    <xsl:text> = </xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:if test="position() &lt; last()">
      <xsl:text>,
</xsl:text>
    </xsl:if>
  </xsl:for-each>

  <!-- Class End -->
  <xsl:text>

  }

</xsl:text>

</xsl:template>


<!-- ***** Zusatz-Methoden für Enumeration ***** -->
<xsl:template match="entity" mode="enumeration-methods">

  <xsl:if test="$generate-comments">
    <xsl:text>    /// &lt;summary&gt;
    /// Gibt den Namen zur Konstante aus der Enumeration zurück.
    /// &lt;param name="pID"&gt; Konstante aus </xsl:text><xsl:value-of select="$entity"/><xsl:text>&lt;/param&gt;.
    /// &lt;returns&gt;Der passende Name zur Konstante.&lt;/returns&gt;
    /// &lt;/summary&gt;
</xsl:text>
  </xsl:if>
  <xsl:text>    public static string GetEnumName(</xsl:text><xsl:value-of select="$entity"/><xsl:text>Enum pID) {
      switch (pID) {
</xsl:text>
  <xsl:for-each select="$generate-entity/enumeration-entries/enumeration-entry[@generate='true']">
    <xsl:sort select="@identifier"/>
    <xsl:text>        case </xsl:text><xsl:value-of select="$entity"/><xsl:text>Enum.</xsl:text><xsl:value-of select="@identifier"/><xsl:text>:
          return "</xsl:text>
    <xsl:call-template name="replace-string">
      <xsl:with-param name="text" select="@name"/>
      <xsl:with-param name="replace" select="'&quot;'"/>
      <xsl:with-param name="with" select="'\&quot;'"/>
    </xsl:call-template>
    <xsl:text>";
</xsl:text>
  </xsl:for-each>
  <xsl:text>        default:
          return "";
      }
    }

</xsl:text>

  <xsl:if test="$generate-comments">
    <xsl:text>    /// &lt;summary&gt;
    /// Gibt eine ArrayList mit allen Enumerations-Items mit ID und Namen zurück.
    /// &lt;returns&gt;Gibt eine ArrayList von &lt;c&gt;PVKeyValueItem&lt;/c&gt;-Objekten zurück.
    /// Das Attribut "ID" enthält das Enumerations-Item, das Attribut "Description" den Namen.&lt;/returns&gt;
    /// &lt;/summary&gt;
</xsl:text>
  </xsl:if>
  <xsl:text>    public static System.Collections.ArrayList GetEnumNames() {
      System.Collections.ArrayList al = new System.Collections.ArrayList(</xsl:text><xsl:value-of select="count($generate-entity/enumeration-entries/enumeration-entry[@generate='true'])"/><xsl:text>);
</xsl:text>
  <xsl:for-each select="$generate-entity/enumeration-entries/enumeration-entry[@generate='true']">
    <xsl:sort select="@identifier"/>
    <xsl:text>      al.Add(new PVKeyValueItem(</xsl:text><xsl:value-of select="$entity"/><xsl:text>Enum.</xsl:text><xsl:value-of select="@identifier"/>
    <xsl:text>, "</xsl:text>
    <xsl:call-template name="replace-string">
      <xsl:with-param name="text" select="@name"/>
      <xsl:with-param name="replace" select="'&quot;'"/>
      <xsl:with-param name="with" select="'\&quot;'"/>
    </xsl:call-template>
    <xsl:text>"));
</xsl:text>
  </xsl:for-each>
  <xsl:text>      return al;
    }

</xsl:text>

</xsl:template>


</xsl:stylesheet>
