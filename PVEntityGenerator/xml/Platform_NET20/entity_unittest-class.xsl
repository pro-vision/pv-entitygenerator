<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0"
>

<xsl:import href="platform_defaults.xsl"/>

<xsl:output method="text" encoding="ISO-8859-1"/>


<xsl:template match="/">
  <xsl:apply-templates select="$db-definition/entities/entity[@name=$entity]"/>
</xsl:template>


<!-- ***** Class File generieren ***** -->
<xsl:template match="entity">
<xsl:if test="$generate-entity/parameters/parameter[@name='generate-entity']='true'
    and $platform/parameters/parameter[@name='generate-unittest']='true'">

  <!-- File Header, package, import statements -->
  <xsl:if test="$platform/parameters/parameter[@name='file-header']!=''">
    <xsl:value-of select="$platform/parameters/parameter[@name='file-header']"/>
    <xsl:text><![CDATA[
]]></xsl:text>
  </xsl:if>
  <xsl:text>using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using NUnit.Framework;
using PVFramework;

namespace </xsl:text><xsl:value-of select="$platform/parameters/parameter[@name='unittest-namespace']"/><xsl:text> {

</xsl:text>

  <!-- Class-Kommentar -->
  <xsl:if test="$generate-comments">
    <xsl:text>  /// &lt;summary&gt;
  /// Unit Test Case for Entity &lt;i&gt;</xsl:text><xsl:value-of select="$entity"/><xsl:text>&lt;/i&gt;.
  /// Generated by PVEntityGenerator
  /// &lt;/summary&gt;
</xsl:text>
  </xsl:if>

  <!-- Class Beginn -->
  <xsl:text>  [TestFixture]
  public class </xsl:text><xsl:value-of select="$entity"/><xsl:text>Test : </xsl:text><xsl:value-of select="$platform/parameters/parameter[@name='unittest-baseclass']"/><xsl:text> {

    [Test]
    public void testObjectInstance() {
      </xsl:text><xsl:value-of select="$entity-class"/><xsl:text> dbo = new </xsl:text><xsl:value-of select="$entity-class"/><xsl:text>();
    }

</xsl:text>


  <!-- Test default methods -->
  <xsl:apply-templates select="." mode="test-default"/>

  <!-- Test Remove Constraints/Cascading Deletes -->
  <xsl:apply-templates select="." mode="test-constraints"/>

  <!-- Test custom create methods -->
  <xsl:apply-templates select="." mode="test-custom-create"/>

  <!-- Test custom find methods -->
  <xsl:apply-templates select="." mode="test-custom-find"/>


  <!-- Placeholder for manual class extensions -->
  <xsl:text>//+++ Custom class extensions START +++
// To prevent deleting your changes from PVEntityGenerator put your manual class extensions only here

//+++ Custom class extensions END +++
</xsl:text>

  <!-- Class End -->
  <xsl:text>
  }

}
</xsl:text>

</xsl:if>
</xsl:template>


<!-- ***** Test default methods ***** -->
<xsl:template match="entity" mode="test-default">

<xsl:if test="$generate-entity/parameters/parameter[@name='generate-home']='true' and $generate-entity/parameters/parameter[@name='generate-findbyprimarykey']='true'">
  <xsl:text>    [Test]
    public void testCreateStoreRemoveAttributes() {

      // test create
</xsl:text>
  <xsl:apply-templates select="." mode="test-createrecord">
    <xsl:with-param name="variable" select="'dbo'"/>
  </xsl:apply-templates>
  <xsl:text>
      // test default values
</xsl:text>

  <!-- test default attributes (not first attribute (primary key), not vstamp, not "@no-unittest") -->
  <xsl:for-each select="attributes/attribute[position()!=1 and @type!='VSTAMP' and not(@no-unittest='true') and not(@deprecated='true') and (@required='false' or @type!='BLOB')]">
    <xsl:variable name="value">
      <xsl:choose>
        <xsl:when test="@required='true' and @type!='VSTAMP' and @type!='BIT' and (@default-value='' or not(@default-value))">
          <xsl:call-template name="test-test-value">
            <xsl:with-param name="attribute" select="."/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="test-default-value">
            <xsl:with-param name="attribute" select="."/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="@type='TIMESTAMP' and $value='null'">
        <xsl:text>      Assert.IsTrue(</xsl:text>
        <xsl:text>dbo.</xsl:text><xsl:value-of select="@name"/><xsl:text>.IsNull</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>      Assert.AreEqual(</xsl:text>

        <xsl:variable name="enum-type">
          <xsl:call-template name="variable-enum-type">
            <xsl:with-param name="attribute" select="."/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:if test="$enum-type!=''">
          <xsl:text>(</xsl:text>
          <xsl:value-of select="concat($platform/parameters/parameter[@name='entity-namespace'],'.',$enum-type)"/>
          <xsl:text>)</xsl:text>
        </xsl:if>

        <xsl:value-of select="$value"/>
        <xsl:text>, dbo.</xsl:text><xsl:value-of select="@name"/>
        <xsl:if test="@type='FLOAT' or @type='DECIMAL'">
          <xsl:text>, 0.000001d</xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>, "test default value </xsl:text><xsl:value-of select="@name"/><xsl:text>");
</xsl:text>
  </xsl:for-each>

  <xsl:text>
      // test set methods
</xsl:text>

  <!-- test set methods (not first attribute (primary key), not vstamp, not "@no-unittest") -->
  <xsl:for-each select="attributes/attribute[position()!=1 and @type!='VSTAMP' and not(@no-unittest='true') and not(@deprecated='true')]">
    <xsl:choose>
      <xsl:when test="@type='BLOB'">
        <xsl:text>      byte[] abytSet_</xsl:text><xsl:value-of select="position()"/>
        <xsl:text> = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09};
      dbo.</xsl:text><xsl:value-of select="@name"/><xsl:text> = abytSet_</xsl:text><xsl:value-of select="position()"/><xsl:text>;
</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>      dbo.</xsl:text><xsl:value-of select="@name"/><xsl:text> = </xsl:text>
        <xsl:call-template name="test-test-value">
          <xsl:with-param name="attribute" select="."/>
        </xsl:call-template>
        <xsl:text>;
</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>

  <xsl:text>
      // test get methods
</xsl:text>

  <!-- test get methods (not first attribute (primary key), not vstamp, not "@no-unittest") -->
  <xsl:for-each select="attributes/attribute[position()!=1 and @type!='VSTAMP' and not(@no-unittest='true') and not(@deprecated='true')]">
    <xsl:choose>
      <xsl:when test="@type='BLOB'">
        <xsl:text>      byte[] abytGet_</xsl:text><xsl:value-of select="position()"/>
        <xsl:text> = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09};
      for (int intIndex=0; intIndex&lt;abytGet_</xsl:text><xsl:value-of select="position()"/><xsl:text>.Length; intIndex++) {
        Assert.AreEqual(abytGet_</xsl:text><xsl:value-of select="position()"/><xsl:text>[intIndex], dbo.</xsl:text><xsl:value-of select="@name"/><xsl:text>[intIndex], "test get BinaryData");
      }
</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>      Assert.AreEqual(</xsl:text>
        <xsl:call-template name="test-test-value">
          <xsl:with-param name="attribute" select="."/>
        </xsl:call-template>
        <xsl:text>, dbo.</xsl:text><xsl:value-of select="@name"/>
        <xsl:if test="@type='FLOAT' or @type='DECIMAL'">
          <xsl:text>, 0.000001d</xsl:text>
        </xsl:if>
        <xsl:text>, "test get </xsl:text><xsl:value-of select="@name"/><xsl:text>");
</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>

  <xsl:text>
      // test store
      dbo.Store(mcon);

      // test retrieve
      </xsl:text><xsl:value-of select="$entity-class"/><xsl:text> dbo2 = </xsl:text>
    <xsl:value-of select="$entity-class"/><xsl:text>Home.FindByPrimaryKey(dbo.</xsl:text>
    <xsl:value-of select="attributes/attribute[position()=1]/@name"/>
    <xsl:text>, mcon);
</xsl:text>

  <!-- test retrieve (not first attribute (primary key), not vstamp, not "@no-unittest") -->
  <xsl:for-each select="attributes/attribute[position()!=1 and @type!='VSTAMP' and not(@no-unittest='true') and not(@deprecated='true')]">
    <xsl:choose>
      <xsl:when test="@type='BLOB'">
        <xsl:text>      byte[] abytRetrieve_</xsl:text><xsl:value-of select="position()"/>
        <xsl:text> = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09};
      for (int intIndex=0; intIndex&lt;abytRetrieve_</xsl:text><xsl:value-of select="position()"/><xsl:text>.Length; intIndex++) {
        Assert.AreEqual(abytRetrieve_</xsl:text><xsl:value-of select="position()"/><xsl:text>[intIndex], dbo2.</xsl:text><xsl:value-of select="@name"/><xsl:text>[intIndex], "test retrieve BinaryData");
      }
</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>      Assert.AreEqual(</xsl:text>
        <xsl:call-template name="test-test-value">
          <xsl:with-param name="attribute" select="."/>
        </xsl:call-template>
        <xsl:text>, dbo2.</xsl:text><xsl:value-of select="@name"/>
        <xsl:if test="@type='FLOAT' or @type='DECIMAL'">
          <xsl:text>, 0.000001d</xsl:text>
        </xsl:if>
        <xsl:text>, "test retrieve </xsl:text><xsl:value-of select="@name"/><xsl:text>");
</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>

  <xsl:text>
      dbo2.Remove(mcon);

    }

</xsl:text>
</xsl:if>

</xsl:template>


<!-- ***** Test Remove Constraints/Cascading Deletes ***** -->
<xsl:template match="entity" mode="test-constraints">
  <xsl:variable name="foreign-key-check" select="key('foreign-key-check', $entity)"/>
  <xsl:variable name="foreign-key-cascading-delete" select="key('foreign-key-cascading-delete', $entity)"/>
  <xsl:variable name="ent" select="."/>

  <!-- Constraint Checks -->
  <xsl:if test="$foreign-key-check and $generate-entity/parameters/parameter[@name='generate-removecheck']='true'">
    <xsl:for-each select="$foreign-key-check">
      <xsl:variable name="ent-foreign" select="../.."/>

      <xsl:text>    [Test]
    public void testCheckRemoveConstraints</xsl:text><xsl:value-of select="position()"/>
      <xsl:text>_</xsl:text><xsl:value-of select="$ent-foreign/@name"/>
      <xsl:text>() {
      // create test records
</xsl:text>
      <xsl:apply-templates select="$ent" mode="test-createrecord">
        <xsl:with-param name="variable" select="'dbo1'"/>
      </xsl:apply-templates>
      <xsl:apply-templates select="$ent-foreign" mode="test-createrecord">
        <xsl:with-param name="variable" select="'dbo2'"/>
      </xsl:apply-templates>

      <xsl:variable name="foreign-enum-type">
        <xsl:call-template name="variable-enum-type">
          <xsl:with-param name="attribute" select="$ent-foreign/attributes/attribute[@name=current()/attribute-ref/@attribute]"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:text>      dbo2.</xsl:text><xsl:value-of select="attribute-ref/@attribute"/><xsl:text> = </xsl:text>
      <xsl:if test="$foreign-enum-type!=''">
        <xsl:text>(</xsl:text>
        <xsl:value-of select="concat($platform/parameters/parameter[@name='entity-namespace'],'.',$foreign-enum-type)"/>
        <xsl:text>)</xsl:text>
      </xsl:if>
      <xsl:text>dbo1.</xsl:text><xsl:value-of select="attribute-ref/@foreign-attribute"/><xsl:text>;
      dbo2.Store(mcon);

      // check constraint
      bool fRemoveConstraint = false;
      try {
        dbo1.Remove(mcon);
      }
      catch (PVExceptionRemoveConstraint) {
        fRemoveConstraint = true;
      }
      dbo2.Remove(mcon);
      Assert.IsTrue(fRemoveConstraint, "Constraint must be thrown");
      dbo1.Remove(mcon);
    }

</xsl:text>
    </xsl:for-each>
  </xsl:if>

  <!-- Cascading Deletes -->
  <xsl:if test="$foreign-key-cascading-delete">
    <xsl:for-each select="$foreign-key-cascading-delete">
      <xsl:variable name="ent-foreign" select="../.."/>

      <xsl:text>    [Test]
    public void testRemoveDependentObjects</xsl:text><xsl:value-of select="position()"/>
      <xsl:text>_</xsl:text><xsl:value-of select="$ent-foreign/@name"/>
      <xsl:text>() {
      // create test records
</xsl:text>
      <xsl:apply-templates select="$ent" mode="test-createrecord">
        <xsl:with-param name="variable" select="'dbo1'"/>
      </xsl:apply-templates>
      <xsl:apply-templates select="$ent-foreign" mode="test-createrecord">
        <xsl:with-param name="variable" select="'dbo2'"/>
      </xsl:apply-templates>

      <xsl:text>      dbo2.</xsl:text><xsl:value-of select="attribute-ref/@attribute"/><xsl:text> = dbo1.</xsl:text><xsl:value-of select="attribute-ref/@foreign-attribute"/><xsl:text>;
      dbo2.Store(mcon);

      // test automatic remove
      dbo1.Remove(mcon);
      </xsl:text><xsl:value-of select="concat($platform/parameters/parameter[@name='entity-namespace'],'.',$ent-foreign/@name)"/><xsl:text> dbo3 = null;
      try {
        dbo3 = </xsl:text><xsl:value-of select="concat($platform/parameters/parameter[@name='entity-namespace'],'.',$ent-foreign/@name)"/><xsl:text>Home.FindByPrimaryKey(dbo2.</xsl:text>
    <xsl:value-of select="$ent-foreign/attributes/attribute[position()=1]/@name"/>
    <xsl:text>, mcon);
      }
      catch (PVExceptionNoRecordFound) {}
      Assert.IsNull(dbo3, "Record must be deleted");
    }

</xsl:text>

    </xsl:for-each>
  </xsl:if>

</xsl:template>


<!-- ***** Test custom create methods ***** -->
<xsl:template match="entity" mode="test-custom-create">
  <xsl:variable name="ent" select="."/>

  <xsl:for-each select="$generate-entity/custom-create-methods/custom-create-method">
    <xsl:text>    [Test]
    public void testCreateCustom</xsl:text><xsl:value-of select="position()-1"/><xsl:text>() {
      </xsl:text><xsl:value-of select="$entity-class"/><xsl:text> dbo = </xsl:text><xsl:value-of select="$entity-class"/><xsl:text>Home.</xsl:text>
    <xsl:value-of select="@name"/><xsl:text>(</xsl:text>
    <xsl:for-each select="method-attribute">
      <xsl:variable name="attribute" select="$ent/attributes/attribute[@name=current()/@name]"/>
      <xsl:call-template name="test-test-value">
        <xsl:with-param name="attribute" select="$attribute"/>
      </xsl:call-template>
      <xsl:text>, </xsl:text>
    </xsl:for-each>
    <xsl:text>mcon);
</xsl:text>

    <xsl:for-each select="method-attribute">
      <xsl:variable name="attribute" select="$ent/attributes/attribute[@name=current()/@name]"/>
      <xsl:if test="$attribute/@type!='VSTAMP'">
        <xsl:text>      Assert.AreEqual(</xsl:text>
        <xsl:call-template name="test-test-value">
          <xsl:with-param name="attribute" select="$attribute"/>
        </xsl:call-template>
        <xsl:text>, dbo.</xsl:text><xsl:value-of select="$attribute/@name"/>
        <xsl:if test="$attribute/@type='FLOAT' or $attribute/@type='DECIMAL'">
          <xsl:text>, 0.000001d</xsl:text>
        </xsl:if>
        <xsl:text>, "test constructor value </xsl:text><xsl:value-of select="@name"/><xsl:text>");
</xsl:text>
      </xsl:if>
    </xsl:for-each>

    <xsl:text>      dbo.Remove(mcon);
    }

</xsl:text>
  </xsl:for-each>

</xsl:template>


<!-- ***** Test custom find methods ***** -->
<xsl:template match="entity" mode="test-custom-find">
  <xsl:variable name="ent" select="."/>

  <xsl:for-each select="$generate-entity/custom-find-methods/custom-find-method[@generate-test='true']">

    <!-- Custom find with custom method attributes must be testet separately -->
    <xsl:choose>
      <xsl:when test="method-attribute[@type!='']">
        <xsl:apply-templates select="." mode="test-custom">
          <xsl:with-param name="ent" select="$ent"/>
          <xsl:with-param name="pos" select="position()-1"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="." mode="test-standard">
          <xsl:with-param name="ent" select="$ent"/>
          <xsl:with-param name="pos" select="position()-1"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>

  </xsl:for-each>

</xsl:template>

<xsl:template match="custom-find-method" mode="test-standard">
  <xsl:param name="ent"/>
  <xsl:param name="pos"/>

    <xsl:text>    [Test]
    public void testFindCustom</xsl:text><xsl:value-of select="$pos"/><xsl:text>_</xsl:text>
    <xsl:value-of select="@name"/><xsl:text>() {
      // create test record
</xsl:text>
      <xsl:apply-templates select="$ent" mode="test-createrecord">
      <xsl:with-param name="variable" select="'dbo'"/>
    </xsl:apply-templates>
    <xsl:for-each select="method-attribute">
      <xsl:variable name="attribute" select="$ent/attributes/attribute[@name=current()/@name]"/>
      <xsl:text>      dbo.</xsl:text><xsl:value-of select="$attribute/@name"/><xsl:text> = </xsl:text>
      <xsl:call-template name="test-test-value">
        <xsl:with-param name="attribute" select="$attribute"/>
        <xsl:with-param name="type" select="@type"/>
        <xsl:with-param name="force-required" select="1"/>
      </xsl:call-template>
      <xsl:text>;
</xsl:text>
    </xsl:for-each>
    <xsl:text>      dbo.Store(mcon);

      // find via custom method
</xsl:text>

    <xsl:choose>
      <xsl:when test="@returns-multiple='true'">
        <xsl:text>      bool wasFound = false;
      List&lt;</xsl:text><xsl:value-of select="$entity-class"/><xsl:text>&gt; result = </xsl:text><xsl:value-of select="$entity-class"/>
        <xsl:text>Home.</xsl:text><xsl:value-of select="@name"/><xsl:text>(</xsl:text>
        <xsl:for-each select="method-attribute">
          <xsl:variable name="attribute" select="$ent/attributes/attribute[@name=current()/@name]"/>
          <xsl:call-template name="test-test-value">
            <xsl:with-param name="attribute" select="$attribute"/>
            <xsl:with-param name="type" select="@type"/>
            <xsl:with-param name="force-required" select="1"/>
            <xsl:with-param name="check-enum" select="0"/>
          </xsl:call-template>
          <xsl:text>, </xsl:text>
        </xsl:for-each>
        <xsl:text>mcon);
      foreach (</xsl:text><xsl:value-of select="$entity-class"/><xsl:text> result_dbo in result) {
        if (result_dbo.</xsl:text><xsl:value-of select="$ent/attributes/attribute[1]/@name"/><xsl:text>==dbo.</xsl:text>
          <xsl:value-of select="$ent/attributes/attribute[1]/@name"/><xsl:text>) {
          wasFound = true;
        }
      }
      Assert.IsTrue(wasFound, "test </xsl:text><xsl:value-of select="@name"/><xsl:text> method");
</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text><![CDATA[      ]]></xsl:text>
        <xsl:value-of select="$entity-class"/><xsl:text> dbo2 = null;
      try {
        dbo2 = </xsl:text><xsl:value-of select="$entity-class"/><xsl:text>Home.</xsl:text><xsl:value-of select="@name"/><xsl:text>(</xsl:text>
        <xsl:for-each select="method-attribute">
          <xsl:variable name="attribute" select="$ent/attributes/attribute[@name=current()/@name]"/>
          <xsl:call-template name="test-test-value">
            <xsl:with-param name="attribute" select="$attribute"/>
            <xsl:with-param name="type" select="@type"/>
            <xsl:with-param name="force-required" select="1"/>
          </xsl:call-template>
          <xsl:text>, </xsl:text>
        </xsl:for-each>
        <xsl:text>mcon);
      }
      catch (Exception) {}
      Assert.IsNotNull(dbo2, "test </xsl:text><xsl:value-of select="@name"/><xsl:text> method");
</xsl:text>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:text>
      // remove test record
      dbo.Remove(mcon);
    }

</xsl:text>

</xsl:template>

<xsl:template match="custom-find-method" mode="test-custom">
  <xsl:param name="ent"/>
  <xsl:param name="pos"/>

    <xsl:text>    [Test]
    public void testFindCustom</xsl:text><xsl:value-of select="$pos"/><xsl:text>_</xsl:text>
    <xsl:value-of select="@name"/><xsl:text>() {
      // only call custom find method with custom parameters
      </xsl:text>

    <xsl:value-of select="$entity-class"/><xsl:text>Home.</xsl:text><xsl:value-of select="@name"/><xsl:text>(</xsl:text>
    <xsl:for-each select="method-attribute">
      <xsl:variable name="attribute" select="$ent/attributes/attribute[@name=current()/@name]"/>
      <xsl:call-template name="test-test-value">
        <xsl:with-param name="attribute" select="$attribute"/>
        <xsl:with-param name="type" select="@type"/>
        <xsl:with-param name="force-required" select="1"/>
      </xsl:call-template>
      <xsl:text>, </xsl:text>
    </xsl:for-each>
    <xsl:text>mcon);
    }

</xsl:text>

</xsl:template>


<!-- Create Test Record -->
<xsl:template match="entity" mode="test-createrecord">
  <xsl:param name="variable" select="'dbo'"/>
  <xsl:for-each select="attributes/attribute[position()!=1 and @required='true' and @type='BLOB']">
    <xsl:text>    byte[] abytCreate_</xsl:text><xsl:value-of select="position()"/><xsl:text> = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09};
</xsl:text>
  </xsl:for-each>
  <xsl:text><![CDATA[      ]]></xsl:text>
  <xsl:value-of select="concat($platform/parameters/parameter[@name='entity-namespace'],'.',@name)"/><xsl:text> </xsl:text><xsl:value-of select="$variable"/><xsl:text> = </xsl:text>
  <xsl:value-of select="concat($platform/parameters/parameter[@name='entity-namespace'],'.',@name)"/><xsl:text>Home.Create(</xsl:text>
  <xsl:for-each select="attributes/attribute[position()!=1 and @required='true' and (@default-value='' or not(@default-value)) and @type!='VSTAMP' and @type!='BIT']">
    <xsl:choose>
      <xsl:when test="@type='BLOB'">
        <xsl:text>abytCreate_</xsl:text><xsl:value-of select="position()"/><xsl:text>, </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="test-test-value">
          <xsl:with-param name="attribute" select="."/>
        </xsl:call-template>
        <xsl:text>, </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
  <xsl:text>mcon);
</xsl:text>
</xsl:template>


</xsl:stylesheet>
